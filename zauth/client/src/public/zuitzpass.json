{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":11936141905000507972,"abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"proof_siblings","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18261670735869299181":{"error_kind":"string","string":"data length is too long"}}},"bytecode":"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","debug_symbols":"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do9Ntntsst1j09w9Fl2hmrvKwo+L3ktPc7eZxEfvpae520zio/fS09xtJvHZWd3cbSbx0Xvpae42k/jovfQ0d5tJfHYvvZerbJq7ysKPa57VRU3FdptNtttsurvNFD57Qm7uNlP4bLfZZLvNJtttNtlus8l2m02222yau80k/l4TcnNXWfhx2RNytttsst1m091tpvDZE3Jzt5nEZ2d1tttsst1mk+02m2y32WS7zaa520zio19uTXP3mMT3zroSH/1ya5q7xyQ++uXWNHePSXz2yy1z95jEZ7/cMnePSfy99szmrrLw47L30uZuM4nP3kuz3WPT3T0mxmDu7jGFz+6lzd1jEp+9l2a7xybbPTbZ7rHJdo9Nc/dYdIVq7iqLPq6520zVVOZuM4nP3kubu80kvndWVxWtudtM4rOzurnbTOKz99LmbjOBv8zdZhIf3Usvc7eZxN9qQr4e3lk6/LjoCfliu80W22223N1mCh89IV/mbjOJz87qbLfZYrvNFttttthus8V2my1zt5nE32pCvsxdZdHHZbvNFttttthus+XuNlP43lldVbTmbjOJz87qbLfZYrvNFttttthus8V2my1zt5nER7/cWubuMYmPfrm1zN1jEp/zcuspPvrl1jJ3jyl8c/eYeDu0zN1jEh/9cmuZu8ckvnfWjR5rmbvKwo/L3kubu80kPnsvzXaPLXf3mBiDubvHFD67lzZ3j0l876wu8dl7abZ7bLHdY4vtHlvm7rHoCtXcVRZ+XPZe2txtJvHZe2lzt5nEZ++lzd1mEp+d1c3dZhKfvZc2d5tJfPZe2txtJvHZvfRerrJl7ioLPy57Qs52my2222y5u80EPttttszdZhKfndXZbrPFdpsttttssd1mi+02W+ZuM4m/14Tc3FUWflz2hJztNltst9lyd5spfPaE3NxtJvHZWZ3tNltot1l/oN1mFz55Qn7hk3vpC5/cS1/43ln3149vLnzyy60Ln/xy68Inv9y68Dkvt57ik19u9Ye5e0zik19uXfjkl1sXPvnl1oVvnnUV/k575uu43lk6/LjkvfSFT95LX/jkvfT1f0t2j13/t+S99IVvPsFW+Oxe2tw9JvHJe+kLn7yXvvDJE+wLnzzBvvDZE2xz91h0hWruKgs/LnkvfeGT99IXvndWl/jkX+e48Ml76QvfvJdW+Oysbu42U/jm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frl1mrvHFL65e0zio19unebuMYmPfrl1mrvHJD765dZp7h6T+FvtmU9zV1n4cdl7aXO3mcRn76XZ7rHT3T0mxmDu7jGFz+6lzd1jEp+9l2a7x062e+xku8dOtnvsNHePRVeo5q6y8OOaZ3VRU5m7zSQ+ey9t7jaT+Oy9tLnbTOGbu81UWjR3m0l89l7a3G0m8b2zrsRn99LmbjOJv9eE3NxVFn5c9oSc7TY72W6z091tpvDZE3Jzt5nEZ2d1ttvsZLvNTrbb7GS7zU622+w0d5tJ/L0m5OausvDjmmd1UVOx3WYn2212urvNFD57Qm7uNlP4bLfZyXabnWy32cl2m51st9nJdpud5m4zic9+uWXuHpP46Jdb09w9JvE5L7ee4qNfbk1z95jE98664u3QNHePSXz0y61p7h6T+Fvtmae5qyz6uOZuMzGImeZuM4mP3ktPtntsurvHfj0Gm+7uMYWP7qWnuXtM4qP30pPtHpts99hku8cm2z02zd1j0RWquass/LjovfQ0d5tJfPReepq7zSQ+ei89zd1mEp+d1c3dZhIfvZee5m4ziY/eS09zt5nEZ/fSe7nKprmrLPq4bLfZZLvNJtttNt3dZgrfO6uritbcbSbx2Vmd7TabbLfZZLvNJtttNtlus2nuNpP4e03IzV1l4cdlT8jZbrPJdptNd7eZwmdPyM3dZhKfndXZbrPJdptNtttsst1mk+02m+ZuM4mPfrk1zd1jCt/cPSbx2S+3zN1jEp/9csvcPSbx2S+3zN1jEp/9csvcPSbx99ozm7vKwo/L3kubu80kPnsvzXaPTXf3mBiDubvHFD67lzZ3j0l89l6a7R6bbPfYZLvHJts9Ns3dY9EVqrmrLPy47L20udtM4rP30uZuM4G/zN1moqJd5m4ziY/O6svcbSbxvbO6xEfvpZe520zio3vpZe42k/hbTciXuass/LjoCfliu80W22223N1mCh89IV/mbjOJz87qbLfZYrvNFttttthus8V2my1zt5nE98660RWquass/LjoCfliu80W22223N1mAp/tNlvmbjOJz87qbLfZYrvNFttttthus8V2my1zt5nER7/cWubuMYmPfrm1zN1jEp/zcuspvnfWFS+3lrl7TOKjX24tc/eYxEe/3Frm7jGFb+4eix5rmbvKwo/L3kubu80kvndWl/ho99hyd4+J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Z2d1tttssN1mg+02G2y32WC7zYa520zi7zUhN3eVhR+XPSFnu80G22023N1mCp89ITd3m0l8dlZnu80G22022G6zwXabDbbbbJi7zSQ++uXWMHePSXz0y61h7h6T+JyXW0/x0S+3hrl7TOKjX24Nc/eYwjd3j0l886yr8PfaM5u7ysKP653V1SDG3G0m8dl7abZ7bLi7x8QYzN09JvDN3WOqlzZ3j0l89l6a7R4bbPfYYLvHBts9NszdY9EVqrmrLPy47L20udtM4rP30uZuM4nP3kubu80kPjurm7vNJD57L23uNpP46L30ae42k/joXvrcy1V2mrvKwo9rntV/XVOdbLfZyXabne5uM4WPnpCf5m4zhc92m51st9nJdpudbLfZyXabnWy32WnuNpP4W03IT3NXWfhx0RPyk+02O9lus9Pdbabw0RPy09xtJvHZWZ3tNjvZbrOT7TY72W6zk+02O83dZhIf/XLrNHePSXzvrCvx0S+3TnP3mMRHv9w6zd1jEh/9cus0d49JfPTLrdPcPSbx99ozm7vKwo/L3kubu80kPnsvzXaPne7uMTEGc3ePKXx2L23uHpP47L002z12st1jJ9s9drLdY6e5eyy6QjV3lUUf19xtpmoqc7eZxGfvpc3dZhLfO6uritbcbSbx2Vnd3G0m8dl7aXO3mcI3d5tJfHYvbe42k/h7TcjNXWXhx2VPyNlus5PtNjvd3WYKnz0hN3ebSXx2Vme7zU622+xku81OttvsZLvNTnO3mcTfa0Ju7iqLPi7bbXay3WYn2212urvNFL53VlcVrbnbTOKzszrbbXay3WYn22022W6zyXabTXO3mcRHv9yaD++sK/HRL7emuXtM4nNebj3FR7/cmubuMYVv7h4Tb4emuXtM4qNfbk1z95jE9866wWOtae4qCz8uei89zd1mEh+9l55s99h0d4/9egw23d1jCp/dS5u7xyS+d1aX+Oi99GS7xybbPTbZ7rFp7h6LrlDNXWXhx0Xvpae520zio/fS09xtJvHRe+lp7jaT+Oysbu42k/jsvbS520zis/fS5m4zic/upfdylU1zV1n4cdkTcrbbbLLdZtPdbSbw2W6zae42k/jsrM52m02222yy3WaT7TabbLfZNHebSfy9JuTmrrLw47In5Gy32WS7zaa720zhsyfk5m4zic/O6my32WS7zSbb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hHw+0G6zC588Ib/wyRPyC588Ib/wvbO6xGdndbTb7MInT8gvfPKE/MInT8jnA+02u/DZvbS5q+zXj28ufPLLrQvfO+tKfPLLrQuf83LrKT755daFb/5yS+GTX27Nh7l7TOKTX25d+OZZV+HvtGe+juudpcOPS95LX/jkvfSFT95LX/hk99iFz95Lu7vHFD67lzZ3j0l89l4a7R678NkTbLR77MJnT7DN3WPRFaq5qyz6uOZuM1VTmbvNJD57L23uNpP43lldVbTmbjOJz87q5m4zic/eS5u7zRS+udtM4rN7aXO3mcTfa0Ju7ioLPy57Qo52m1347Am5u9tM4bMn5OZuM4nPzupot9mFz56Qo91mFz57Qo52m1347F56K1fZddy9JuRot9mFz56Qo91mFz57Qo52m1347Ak52m124bOzOtptduGzJ+Rot9mFz+6lzd1mEp/9csvcPSbx2S+3zN1jEp/zcuspPvvllrl7TOAXc/eYeDtUzN1jEh/9cquYu8ckvnfWDR5rFXNXWfhx0XvpYu42k/jovXRhu8eKu3vs12Ow4u4eU/joXrqYu8ckvndWl/jovXRhu8cK2z1W2O6xYu4ei65QzV1l4cdF76WLudtM4qP30sXcbSbx0XvpYu42k/jsrG7uNpP46L10MXebSXz0XrqYu80kPruX3stVVsxdZeHHZU/I2W6zwnabFXe3mcBnu82KudtM4rOzOtttVthus8J2mxW226yw3WbF3G0m8feakJu7ysKPy56Qs91mhe02K+5uM4XPnpCbu80kPjurs91mhe02K2y3WWG7zQrbbVbM3WYS3zvrisc3xdw9JvHRL7eKuXtM4nNebj3FZ7/cMnePSXz2yy1z95jEZ7/cMnePSfy99szmrrLw47L30uZuM4nP3kuz3WPF3T0mxmDu7jGFz+6lzd1jEp+9l2a7xwrbPVbY7rHCdo8Vc/dYdIVq7ioLPy57L23uNpP43lld4qN/naOYu81URWvuNpP47Kxu7jYT+NXcbSbx0Xvpau42k/joXvriZONvNSGv5q6y8OOiJ+SV7TarbLdZdXebKXz0hLyau80kPjurs91mle02q2y3WWW7zSrbbVbN3WYKfy9XWTV3lYUfFz0hr2y3WWW7zaq720zhoyfk1dxtJvHZWZ3tNqtst1llu80q221W2W6zau42k/jol1vV3D0m8dEvt6q5e0zic15uPcM3d4+Jl1vV3D0m8dEvt6q5e0zie2ddiW+edRX+Xntmc1dZ+HHZe2lzt5nCN3eVSXy0e6y6u8fEGMzdPabwvbO66qXN3WMSn72XZrvHKts9Vtnuscp2j1Vz91h0hWruKgs/Lnsvbe42k/jsvbS520zis/fS5m4zic/O6uZuM4nP3kubu80kPnsvbe42k/jsXnovV1k1d5WFH5c9IWe7zSrbbVbd3WYKnz0hN3ebSXx2Vme7zSrbbVbZbrPKdptVttusmrvNJP5eE3JzV1n4cdkTcrbbrLLdZtXdbabw2RNyc7eZxEdn9YPtNjvYbrOD7TY72G6z4+GddSU+upc+zF1l4vHNYe4ek/jol1uHuXtM4Zu7xyQ++uXWYe4ek/jol1uHuXtM4qNfbh3m7jGJv9We+TB3lYUfF72XPszdZhIfvZc+2O6xw9099usx2OHuHlP47F7a3D0m8dF76YPtHjvY7rGD7R472O6xw9w9Fl2hmrvKwo9rntVFTWXuNpP46L30Ye42k/jovfRh7jZT+OZuM5UWzd1mEp+9lzZ3m0l876wr8dm9tLnbTOLvNSE3d5WFH5c9IWe7zQ622+xwd5spfPaE3NxtJvHZWZ3tNjvYbrOD7TY72G6zg+02O8zdZhJ/rwm5uass/LjmWV3UVGy32cF2mx3ubjOFz56Qm7vNFD7bbXaw3WYH2212sN1mB9ttdrDdZoe520zis19umbvHJD775Za5e0zic15uPcVnv9wyd49JfO+sq94OmbvHJD775Za5e0zi77VnNneVRR/X3G2mBjHmbjOJz95Ls91jh7t7TIzB3N1jCp/dS5u7xyQ+ey/Ndo81tnussd1jje0ea+buseAKtT28s3T4cdF76WbuNpP46L10M3ebSXz0XrqZu80kPjurm7vNJD56L93M3WYSH72XbuZuM4mP7qXbXq6yZu4qiz4u223W2G6zxnabNXe3mcL3zuqqojV3m0l8dlZnu80a223W2G6zxnabNbbbrJm7zST+XhNyc1dZ+HHZE3K226yx3WbN3W2m8NkTcnO3mcRnZ3W226yx3WaN7TZrbLdZY7vNmrnbTOKjX241c/eYwjd3j0l89MutZu4ek/jol1vN3D0m8dEvt5q5e0zio19uNXP3mMTfa89s7ioLPy57L23uNpP47L002z3W3N1jYgzm7h5T+Oxe2tw9JvHZe2m2e6yx3WON7R5rbPdYM3ePRVeo5q6y8OOy99LmbjOJz95Lm7vNFL6520xVtOZuM4nPzurmbjOJ753VJT57L23uNpP47F7a3G0m8feakJu7ysKPy56Qs91mje02a+5uM4XPnpCbu80kPjurs91mje0262y3WWe7zTrbbdbN3WYS3zvrBleo3dxVFn5c9IS8s91mne026+5uM4HPdpt1c7eZxGdndbbbrLPdZp3tNutst1lnu826udtM4qNfbnVz95jER7/c6ubuMYnPebn1FN8764qXW93cPSbx0S+3url7TOKjX251c/eYwjd3j0WPtcxdZeHHRe+lu7nbTOJ7Z3WJj3aPdXf3mBiDubvHFD67lzZ3jyl8c/eYxGfvpdnusc52j3W2e6ybu8eiK1RzV1n4cdl7aXO3mcRn76XN3WYSn72XNnebSXx2Vjd3m0l89l7a3G0m8dl7aXO3mcRn99J7ucq6uass/LjsCTnbbdbZbrPu7jZT+OwJubnbTOKzszrbbdbZbrPOdpt1ttuss91m3dxtJvH3mpCbu8rCj8uekLPdZp3tNuvubjOFz56Qm7vNJD47q7PdZp3tNutst1lnu806223Wzd1mCt/cVaYe35i7xyQ+++WWuXtMvR0yd49JfHbWNXePSfwXZ936mOvHXy7/1Kz/G9B0A1peQOPVxi8NVNyAqhvQizNMLccn0FmeADU3oO4GNNyATjeg6Qa0zIBebXHSQMUNqLoBuX1Sv9yG1NYPoNJbewLU3YCGG9DpBjTdgJYZ0MvNPxKouAFVN6DDDcjtk7q6fVJXt0/q6vZJXd0+qavbJ/Xh9kl9uH1Sv9y40kf7AJrzCdDhBtTcgLob0Fbf+BrmppPw46K/ITbMzSgK39yMIvHRv5M1zM0o4htiw9yMIvHbVh+0e5lUhrlJRX40oL/3PdhmlME2owx3M4r4YGabUYa5GUV8C2ewzSiDbUYZbDPKYJtRhrkZJbpGMjephB+XndXNzSsSn92rs80ow92MImoqdzOKwmdndXMzisRHv+YabDPKYJtRBtuMMthmlGFuRhHviYa5GUXie2ddiY/+Ha6xl+lkmJtOwo/LnpCzzSiDbUYZ7mYUhc/ee5ubUSS+d1ZXJSHbjDLYZpTBNqMMthllsM0ow9yMIvG3coEPc5NK+HHR7vBhbl6R+Gh3+DA3r0h8tDt8LPNeWuGjs/r5QGf184GekJ8P9LfNzgf622bnwzvrSnx0L30+tpqQn4+tJuTnAz0hPx/oCflZ0BPys6An5GdBT8jPgp6Qny/3HMWmxcLO6gU9IT8LekJ+FvSE/CzsXrqye+m61YT8rFtNyM+KnpCfL3diBeOjJ+RnRU/Iz4qekJ8VPSE/KzurH+ysfrAn5Ad7Qn6wJ+Qv95sF47N7aXN3mvg1nNPchSbxvbOuxPfOugrf3G0m8dG/w3Wau80kPufl1lN876wr8Tkvt57is7OuuXtM4rOzrrl7TOGbu8ckPjvrmrvHJD4765q7x8SD49PcPSbx9/o22F6ustPcVab2B2z32Ml2j51s99jp7h4T2xu2e+w0d4+pETDbPXay3WMn2z12st1jJ9s9drLdY6e5eyy6QjV3lYUfl/1tMHO3mcRnfxvM3G0m8dnfBnN3jyl8dlY3d49JfPa3wczdYxKf/W0wtnvsZLvHTnP3WHSFau4qCz8ue0Ju7jZT+OZuM4nPnpCbu8pURevuHlP47Kxu7h6T+OwJubl7TOKzJ+Rs99hku8emuXssuEKd5q6y8OOiJ+Tz4Z3VJT56Qj7N3WYSHz0hn+7uMYXPzurm7jGJj56QT3P3mMRHT8gn2z022e6xae4eEw8Qprl7TOKjX25Nc/eYwjd3j4nnH9PcPSbxzV9uzY96v84nH5zmbjCJ7511Jb75yy2Fv9Veepq7xMKPi95LT3P3mMI3d49JfPReepq7x9Qcydw9JvG9s7pqRtnusWnuHpP46L30NHePSXz2BNvcPSbx99pLm7vKwo/L3kubu80kPnsvbe42k/jsvbS520zis7O6udtM4rP30uZuM4nP3kubu80kPruX3sttNvdym02222yy3WaT7TabbLfZZLvNJtttNtlus8l2m02222yy3WaT7TabbLfZZLvN5l5us7mX22yy3WaT7TabbLfZZLvNJtttNtlus8l2m02222yy3WaT7TabbLfZZLvNJtttNs3dZurxjbmrTOKzX26Zu8cUvrl7TOKzX26Zu8ckPvvllrl7TOKzX26Zu8ck/l57ZnNXWfhx0XvpZe42k/jovfQyd5VJfPReej28s7rER/fSy9w9JvHRe+ll7h6T+OgJ9mK7xxbbPbbM3WPBFeoyd5WFH9c8q4uaytxtJvHRe+ll7jaT+Oi99DJ3myl8c7eZSovmbjOJj95LL3O3mcT3zroSn91Lm7vNJP5WE/Jl7ioLPy57Qs52my2222y5u80UPntCbu42k/jsrM52my2222yx3WaL7TZbbLfZMnebSfy9JuTmrrLw45pndVFTsd1mi+02W+5uM4XPnpCbu80UPttttthus8V2my2222yx3WaL7TZb5m4ziY9+ubXM3WMSH/1ya5m7xyQ+5+XWU3z0y61l7h6T+N5ZV7wdWubuMYmPfrm1zN1jEn+vPbO5qyz6uOZuMzWIMXebSXz2XprtHlvu7jExBnN3jyl8di9t7h6T+Oy9NNs9ttjuscV2jy22e2yZu8eiK1RzV1n4cdl7aXO3mcRn76XN3WYSn72XNnebSXx2Vjd3m0l89l7a3G0m8dl7aXO3mcRn99J7ucqWuass9rjrgXabXfjkCfmFT56QX/jkCfmF753Vf13RXvjkCfmFT87qFz45q1/45An5hU+ekK8H2m124ZN76Quf3Etf+DtNyK/jemfp8OOSJ+QXPnlCfuGTJ+QXPnlCfuGTJ+TrYe42k/jsrI52m1345An5he+dpSU+eUJ+4bN7aXO3mcQnv9y68Mkvt9bD3D0m8ckvty58zsutp/jkl1sXvnfWlfjkl1sXPvnl1oVPfrl14ZtnXYW/157Z3FUWflz2XtrcbSbx2XtptHvswmfvpd3dYwqf3Uubu8ckPnsvjXaPXfjsCTbaPXbhsyfY5u6x6ArV3FUWflz2XtrcbSbx2Xtpc7eZwjd3m6mK1txtJvHZWd3cbSbxvbO6xGfvpc3dZhKf3Uubu80k/l4TcnNXWfhx2RNytNvswmdPyN3dZgqfPSE3d5tJfHZWR7vNLnz2hBztNrvw2RNytNvswmf30lu5yq7j7jUhR7vNLnz2hBztNrvw2RNytNvswmdPyNFuswufndXRbrMLnz0hR7vNLnx2L23uNpP46Jdbxdw9JvHRL7eKuXtM4nNebj3F98664uVWMXePSXz0y61i7h6T+OiXW8XcPabwzd1jwWOtYu4qCz8uei9dzN1mEt87q0t8tHusuLvHfj0GK+7uMYWP7qWLuXtM4Zu7xyQ+ei9d2O6xwnaPFbZ7rJi7x6IrVHNXWfhx0XvpYu42k/jovXQxd5tJfPReupi7zSQ+O6ubu80kPnovXczdZhIfvZcu5m4zic/upfdylRVzV1n4cdkTcrbbrLDdZsXdbabw2RNyc7eZxGdndbbbrLDdZoXtNitst1lhu82KudtM4u81ITd3lYUflz0hZ7vNCtttVtzdZgqfPSE3d5tJfHZWZ7vNCtttVthus8J2mxW226yYu80UvrmrTD2+MXePSXz2yy1z95jE9866Ep/9csvcPSbx2S+3zN1jEp/9csvcPSbx99ozm7vKwo/L3kubu80kPnsvzXaPFXf3mBiDubvHFD67lzZ3j0l89l6a7R4rbPdYYbvHCts9VszdY9EVqrmrLPy47L20udtM4Fdzt5nER/86RzV3m4mKtpq7zSQ+OqtXc7eZxEfvpau520zio/fS1dxtpvDN3WYSf6sJeTV3lYUfFz0hr2y3WWW7zaq720zhoyfk1dxtJvHZWZ3tNqtst1llu80q221W2W6zau42k/hbTciruass/LjoCXllu80q221W3d1mCp89ITd3m0l8dlZnu80q221W2W6zynabVbbbrJq7zSQ++uVWNXePSXz0y61q7h6T+JyXW0/x0S+3qrl7TOKjX25Vc/eYwjd3j0l886yr8PfaM5u7ysKP653V1SDG3G0m8dl7abZ7rLq7x8QYzN09JvDN3WOqlzZ3j0l89l6a7R6rbPdYZbvHKts9Vs3dY9EVqrmrLPy47L20udtM4rP30uZuM4nP3kubu80kPjurm7vNJD57L23uNpP47L20udtM4rN76b1cZdXcVRZ+XPOsLmoqttusst1m1d1tpvDZE3Jzt5nCZ7vNKtttVtlus8p2m1W226yy3WbV3G0m8feakJu7ysKPi56QH2y32cF2mx3ubjOFj56QHw/vrC7x0Vn9YLvNDrbb7GC7zQ622+xgu80Oc7eZxEe/3DrM3WMS3zvrSnz0y63D3D0m8dEvtw5z95jER7/cOszdYxIf/XLrMHePSfyt9syHuass/LjovfRh7jaT+Oi99MF2jx3u7jExBnN3jyl8di9t7h6T+Oi99MF2jx1s99jBdo8dbPfYYe4ei65QzV1l0cc1d5upmsrcbSbx2Xtpc7eZxPfO6qqiNXebSXx2Vjd3m0l89l7a3G2m8M3dZhKf3Uubu80k/l4TcnNXWfhx2RNyttvsYLvNDne3mcJnT8jN3WYSn53V2W6zg+02O9hus4PtNjvYbrPD3G0m8feakJu7yqKPy3abHWy32cF2mx3ubjOF753VVUVr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lXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFO5553KPe9U7nmncs/7q1PdLdMs1anc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO75oHLPB5V7Pqjc80Hlno9Xp7pbpllqULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweV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543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqNzzRuWeNyr3vFG5543KPW9U7nmjcs8blXveqdzzTuWedyr3vFO55/3Vqe6WaZbqVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq97xTueedyj3vVO55p3LPO5V73qnc807lnncq93xQueeDyj0fVO75oHLPx6tT3S3TLDWo3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+aByzweVez6o3PNB5Z4PKvd8ULnng8o9H1Tu+Ujuno9Rv+52vpw/+8cH5X9ddS31rx+ev6/k63z92a0t58df+9d1l1L+Vvbxq5C5x7Q8hdxj/PrpvepvCpl7AkxUyPOVyFP2bwqZe7gESmTuuRUokblHYpxEJpfxcRKZHN0HSmTuHQEokbnXD6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISmfw7FTiJTP4JDKBEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISmfyrMTiJTP5BGqBEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISmfwbTjiJTP55KKBEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISmfyLajiJTP6xNqBEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabEISOZN/3xAmkTP5pxOBEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSWTyr43iJDL5h0yBEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSWTyb//iJDL5Z4WBEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSWTyL3HjJDL5R76BEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSWTXZhOTyK7NJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hEDm02MYkc2myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSeTUZhOTyKnNJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hELm02MYlc2myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSeTWZhOTyK3NJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hEHm02MYk82myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarMJSeR6abMJSeR6abMJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFFm01MIos2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISWbXZxCSyarMJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFNm01MIps2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGIS2bXZxCSya7MJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFDm01MIoc2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISObXZxCRyarMJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFLm01MIpc2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISubXZxCRya7MJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFHm01MIo82m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabEISuV/abEISuV/abIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJZNFmE5PIos0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmERWbTYxiazabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJZNNmE5PIps0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmER2bTYxiezabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJ5NBmE5PIoc0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmERObTYxiZzabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJ5NJmE5PIpc0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmERubTYxidzabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJ5NFmE5PIo80mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabkESelzabkESelzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhJZtNnEJLJoswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYmkVWbTUwiqzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhLZtNnEJLJpswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYmkV2bTUwiuzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhI5tNnEJHJoswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYmkVObTUwipzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhK5tNnEJHJpswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYmkVubTUwitzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhJ5tNnEJPJoswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYikfX10mYTkcinkNpsghKpzSYokdpsghLZVciYRGqzCUqkNpugRGqzCUqkNpugRGqziUlk0WYTk8iizSYokdpsghKpzSYokV2FjEmkNpugRGqzCUqkNpugRGqzCUqkNpuYRFZtNjGJrNpsghKpzSYokdpsghLZVciYRGqzCUqkNpugRGqzCUqkNpugRGqziUlk02YTk8imzSYokdpsghKpzSYokV2FjEmkNpugRGqzCUqkNpugRGqzCUqkNpuYRHZtNjGJ7NpsghKpzSYokdpsghLZVciYRGqzCUqkNpugRGqzCUqkNpugRGqziUnk0GYTk8ihzSYokdpsghKpzSYokV2FjEmkNpugRGqzCUqkNpugRGqzCUqkNpuYRE5tNjGJnNpsghKpzSYokdpsghLZVciYRGqzCUqkNpugRGqzCUqkNpugRGqziUnk0mYTk8ilzSYokdpsghKpzSYokV2FjEmkNpugRGqzCUqkNpugRGqzCUqkNpuYRG5tNjGJ3NpsghKpzSYokdpsghLZVciYRGqzCUqkNpugRGqzCUqkNpugRGqziUnk0WYTk8ijzSYokdpsghKpzSYokV2FjEmkNpugRGqzCUqkNpugRGqzCUqkNpuQRJaXNpuQRJaXNpugRGqzCUqkNpugRHYVMiaR2myCEqnNJiiR2myCEqnNJiiR2mxiElm02cQksmizCUqkNpugRGqzCUpkVyFjEqnNJiiR2myCEqnNJiiR2myCEqnNJiaRVZtNTCKrNpugRGqzCUqkNpugRHYVMiaR2myCEqnNJiiR2myCEqnNJiiR2mxiEtm02cQksmmzCUqkNpugRGqzCUpkVyFjEqnNJiiR2myCEqnNJiiR2myCEqnNJiaRXZtNTCK7NpugRGqzCUqkNpugRHYVMiaR2myCEqnNJiiR2myCEqnNJiiR2mxiEjm02cQkcmizCUqkNpugRGqzCUpkVyFjEqnNJiiR2myCEqnNJiiR2myCEqnNJiaRU5tNTCKnNpugRGqzCUqkNpugRHYVMiaR2myCEqnNJiiR2myCEqnNJiiR2mxiErm02cQkcmmzCUqkNpugRGqzCUpkVyFjEqnNJiiR2myCEqnNJiiR2myCEqnNJiaRW5tNTCK3NpugRGqzCUqkNpugRHYVMiaR2myCEqnNJiiR2myCEqnNJiiR2mxiEnm02cQk8mizCUqkNpugRGqzCUpkVyFjEqnNJiiR2myCEqnNJiiR2myCEqnNJiSR9aXNJiSR9aXNJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hEFm02MYks2myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSWTVZhOTyKrNJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hENm02MYls2myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSWTXZhOTyK7NJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hEDm02MYkc2myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSeTUZhOTyKnNJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hELm02MYlc2myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarOJSeTWZhOTyK3NJiiR2myCEqnNJiiRXYWMSaQ2m6BEarMJSqQ2m6BEarMJSqQ2m5hEHm02MYk82myCEqnNJiiR2myCEtlVyJhEarMJSqQ2m6BEarMJSqQ2m6BEarMJSWR7abMJSWR7abMJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFFm01MIos2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISWbXZxCSyarMJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFNm01MIps2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGIS2bXZxCSya7MJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFDm01MIoc2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISObXZxCRyarMJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFLm01MIpc2m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabGISubXZxCRya7MJSqQ2m6BEarMJSmRXIWMSqc0mKJHabIISqc0mKJHabIISqc0mJpFHm01MIo82m6BEarMJSqQ2m6BEdhUyJpHabIISqc0mKJHabIISqc0mKJHabEIS2V/abEIS2V/abIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJZNFmE5PIos0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmERWbTYxiazabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJZNNmE5PIps0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmER2bTYxiezabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJ5NBmE5PIoc0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmERObTYxiZzabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJ5NJmE5PIpc0mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabmERubTYxidzabIISqc0mKJHabIIS2VXImERqswlKpDaboERqswlKpDaboERqs4lJ5NFmE5PIo80mKJHabIISqc0mKJFdhYxJpDaboERqswlKpDaboERqswlKpDabkESOlzabkESOlzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhJZtNnEJLJoswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYmkVWbTUwiqzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhLZtNnEJLJpswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYmkV2bTUwiuzaboERqswlKpDaboER2FTImkdpsghKpzSYokdpsghKpzSYokdpsYhI5tNnEJHJoswlKpDaboERqswlKZFchYxKpzSYokdpsghKpzSYokdpsghKpzSYm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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"use jwt::JWT;\nuse std::{hash::{poseidon2::Poseidon2::hash, }, hash};\nuse trees::{merkle::{Calculator, MerkleTree}};\n\n\n\n// I know a valid RS256 JWT whose email claim is in the approved merkle-set.\n/*\nWhat's going on\n\nJWT verification\nYou pass in the Base64 encoded header and payload (data), your RSA public key limbs, Redc params and signature limbs.\nThe library decodes the payload, hashes with SHA256 under the hood (or does a partial-hash variant), and checks the RSA signature.\n\njwt.get_claim_string(\"email\")\nPulls the \"email\" claim bytes out of the JSON payload.\nYou can choose to only extract it, or additionally assert_claim_string(...) if you want it as a public input.\n\nMerkle proof\nWe turn the email bytes into a field-based leaf hash.\nThen we run your merkle-proof code over proof_nodes (the sibling hashes) and proof_path_bits (the left/right path indicators).\nFinally you assert that the computed root equals the public merkle_root.\n*/\n\nglobal MAX_EMAIL_LENGTH:   u32 = 64; \nglobal MAX_DATA_LENGTH: u32 = 512; // max length of signed data (headerb64 + \".\" + payloadb64)\nglobal MAX_NONCE_LENGTH: u32 = 32; // we are verifying `nonce` claim\nglobal M: u32 = 2;\n\n// how many Field-limbs we'll chunk the email into before hashing:\nglobal LEAF_LIMBS:  u32 = 8;\n\n// Merkle parameters:\nglobal TREE_DEPTH:  u32 = 8;   // e.g. a 2^8-leaf tree //256 participants max at Zuitzerland\n\n// Constants for the PCD Merkle Tree\nglobal PCD_TREE_DEPTH: u32 = 10;  // Allowing for more PCDs than participants\n\n\nfn main(\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    pubkey_modulus_limbs: pub [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    merkle_root:           pub Field,\n    proof_siblings:        [Field; TREE_DEPTH],  // sibling hashes\n    proof_index:           Field,                // leaf index in the tree\n\n) {\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    // Verify `iss` claim value is \"test\"\n    //TODO: Is the below line needed?\n    //jwt.assert_claim_string(\"iss\".as_bytes(),  BoundedVec::<u8, 15>::from_array(\"http://test.com\".as_bytes()));\n\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n    let email_fields: [Field; M] = boundedvec_to_fields(email);\n    // 2) Poseidon-hash those limbs down to one Field\n    let leaf: Field = hash(email_fields, LEAF_LIMBS);\n    // 3) Verify the Merkle proof\n    belongs_to_merkle_tree(merkle_root, poseidon_hasher, leaf, proof_index, proof_siblings);\n\n}\n\n//-----------------------------------------------------------------------------\n// Byte to field conversion (truncates the 32nd byte)\n// from here: https://github.com/noir-lang/noir/blob/5d782f020f6aec6aaa8a445c3a6a5fb9b275e3c6/test_programs/execution_success/ram_blowup_regression/src/main.nr\n//-----------------------------------------------------------------------------\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    let mut v: Field     = 1;\n    let mut high: Field  = 0 as Field;\n    let mut low:  Field  = 0 as Field;\n\n    // pack bytes16..30 into `low`, bytes0..14 into `high`, ignore byte31\n    for i in 0..15 {\n        low  = low  + (bytes32[15 + 15 - i] as Field) * v;\n        v    = v    * 256;\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // byte15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n//-----------------------------------------------------------------------------\n// Chop a BoundedVec<u8,N> into M chunks of 32-bytes and convert each\n//-----------------------------------------------------------------------------\nfn boundedvec_to_fields(vec: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> [Field; M] {\n    let mut fields: [Field; M] = [0; M];\n    for i in 0..M {\n        // build a 32-byte window\n        let mut chunk: [u8; 32] = [0; 32];\n        for j in 0..32 {\n            let idx = i * 32 + j;\n            if idx < vec.len() {\n                chunk[j] = vec.storage()[idx];\n            }\n        }\n        fields[i] = field_from_bytes_32_trunc(chunk);\n    }\n    fields\n}\n\nfn belongs_to_merkle_tree(root: Field, hasher : fn([Field; 2]) -> Field, leaf : Field, indexes : Field, hash_path: [Field; TREE_DEPTH]) {\n    let mut mt = MerkleTree::from(root, hasher);\n    mt.membership(leaf, indexes, hash_path);\n}\n\n// Create a hasher function that can be used with MerkleTree\npub fn poseidon_hasher(inputs: [Field; 2]) -> Field {\n    hash(inputs,2)\n}\n\n// Function to add a PCD hash to the PCD Merkle Tree\nfn add_pcd_to_merkle_tree(\n    pcd_hash: Field,\n    pcd_merkle_root: Field,\n    proof_siblings: [Field; PCD_TREE_DEPTH],\n    proof_index: Field\n) -> Field {\n    // Create a Merkle Tree instance with the current root\n    let mut pcd_tree = MerkleTree::from(pcd_merkle_root, poseidon_hasher);\n    \n    // Add the PCD hash to the tree and get the updated root\n    pcd_tree.add(pcd_hash, proof_index, proof_siblings);\n    \n    // Return the new root after adding the PCD hash\n    pcd_tree.root\n}\n\n// Function to verify that a PCD hash exists in the PCD Merkle Tree\nfn verify_pcd_in_merkle_tree(\n    pcd_hash: Field,\n    pcd_merkle_root: Field,\n    proof_siblings: [Field; PCD_TREE_DEPTH],\n    proof_index: Field\n) -> bool {\n    // Create a Merkle Tree instance with the root\n    let pcd_tree = MerkleTree::from(pcd_merkle_root, poseidon_hasher);\n    \n    // Calculate the expected root if the PCD hash is at the given index\n    let calculated_root = pcd_tree.calculate_root(pcd_hash, proof_index, proof_siblings);\n    \n    // Compare the calculated root with the provided root\n    calculated_root == pcd_merkle_root\n}\n\n#[test]\nfn test_merkle_membership() {   \n\n    // Create test data for a simple Merkle tree\n    let leaf = 42;\n    let indexes = 0; // Position in the tree\n    // 2) build a dummy sibling path\n    let hash_path: [Field; TREE_DEPTH] = [123; TREE_DEPTH];\n    // 3) build tree and get the real root\n    let root: Field = MerkleTree::new(poseidon_hasher).calculate_root(leaf, indexes, hash_path);\n    let mut mt1 = MerkleTree::from(root,poseidon_hasher);\n    \n    // Test the membership function\n    belongs_to_merkle_tree(root, poseidon_hasher, leaf, indexes, hash_path);\n}\n\n#[test(should_fail)]\nfn test_merkle_membership_wrong_leaf() {\n    // Create test data for a simple Merkle tree\n    let leaf = 42;\n    let indexes = 0; // Position in the tree\n    let hash_path = [123, 234, 345, 456, 567, 678, 789, 890];\n    \n    // Calculate what the root should be by manually applying the hash function\n    // This simulates what would happen inside the MerkleTree::membership function\n    let node1 = poseidon_hasher([leaf, hash_path[0]]);\n    let root = poseidon_hasher([node1, hash_path[1]]);\n\n    // Negative test case\n    let wrong_leaf = 43;\n    belongs_to_merkle_tree(root, poseidon_hasher, wrong_leaf, indexes, hash_path);\n}\n\n#[test]\nfn test_main() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n\n    // Create test data for a simple Merkle tree\n    let expected_email: BoundedVec<u8, 64> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    let email_fields: [Field; M] = boundedvec_to_fields(expected_email);\n    let leaf: Field = hash(email_fields, LEAF_LIMBS);\n    let indexes = 0; // Position in the tree\n    // 2) build a dummy sibling path\n    let hash_path: [Field; TREE_DEPTH] = [123; TREE_DEPTH];\n    // 3) build tree and get the real root\n    let root: Field = MerkleTree::new(poseidon_hasher).calculate_root(leaf, indexes, hash_path);\n    let mut mt1 = MerkleTree::from(root,poseidon_hasher);\n    main(data, base64_decode_offset, pubkey_modulus_limbs, redc_params_limbs, signature_limbs, root, hash_path, indexes)\n\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt: JWT<512> = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 64> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 64> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n// #[test]\n// fn test_other_inputs(){\n//     //https://github.com/shield-labs/zklogin/blob/main/packages/contracts/noir/jwt/src/lib.nr\n//     global pubkey_limbs: [Field; 18] = [0x9d9b7ab520532396758488b2100155, 0x87ff0f733247ea1ae377d26bdd60aa, 0x55e1805ec2babe74ebadb5de3c29a7, 0x4131e289b5519e562dff8935a669e2, 0xe974f2f0179abc0cc837efb26a9d5d, 0x72f158dfb2a2ba0fd881d8742426ec, 0x7e56e9182ef83caea0a45cfdaba45a, 0xc2b9b23f6684f0442257dbb8a37291, 0xfc0ecae4fe9f8be5c52a91edd59db2, 0x3ba9bd0376ade89881c7bafa2b36de, 0x3548bec7032b97739300f7fd72769b, 0x6a5b4b975ccf938c5e63ee41d57c7c, 0x4fabc9dbb6a9157f91a87adaff6e66, 0x303d705edf9cae022cd91f57f332b6, 0x1834cc2b65d9d2cab6dd210ba58cad, 0x43b9c3ca0df606d243d4c442794829, 0x5239e9f174adc5871d580714b1eb98, 0xe1];\n//     global pubkey_redc_limbs: [Field; 18] = [0x1e7578875458139006e47aac5c17fb, 0x249a5affa65fe288cb0df8ab6548be, 0xc29ec9b115f3132ff5fb71e744fba3, 0xbde4d1e1b2e894dd482277dc14aba5, 0x675f382edc2e53fabb2c785f0dd7e8, 0x8af86434e50f50ddfc9b46ce2c8990, 0xbaf8f36a4caec8a61d14be456599d3, 0x4ac14c9865afb8da5ab36b76e6d651, 0x2be72e03504024bbc777e0a1e9d16d, 0x249a0c4d673705ab5ad1757a225fea, 0x0300712f5005899fffeb1289f9ef4b, 0x73eb759f585e597acb40bfbf59efed, 0xe070a169f35358c7ead1df56d02d4b, 0x5657e0c005b6bca107abd9024b4dd1, 0xe6da2103c7938911ca44a5e641c541, 0xc98e9e1235394e0eb2b87143fd42c3, 0xdb1c76abaf095069edf0ea5248ef95, 0x0122];\n//     global signature_limbs: [Field; 18] = [ 0xabf49b8204494364afed7815aae9ba, 0x8888b30c7c97cdc0db80766909eba6, 0x5bd07a0786375af02d5f8e9cf9e0bb, 0xb5b1f36ae1cd61952109a814129827, 0xbd011faeecf1eb1ea383e81e1b424e, 0xdb819268100bedf9bb00ceae0c074a, 0x0eaeb846fc824d344bba37468c316d, 0x9123576355f3f5e896ea786a86ce8a, 0x1b9d1c8c412149b3c82e6498a732a9, 0x3d8cbd4f7856947f02ff19e8c478d0, 0x1d3f1389db68a6d6168d9e8104e742, 0x134d7ca6427322a9f62176146be4dc, 0x072d9968d8070f0612a7a781eb3cd0, 0x29a01c7d38758d3cb1ab0a45f9f3e7, 0xa92f67bad1f1995d9e72c23bfa469d, 0x9139299fb1abcc7c45a0305a92a454, 0x6f7998d04ba5abf002a11808d0de0e, 0x42 ];\n//     global header_base64url: [u8; 102] = \"eyJhbGciOiJSUzI1NiIsImtpZCI6ImE1MGY2ZTcwZWY0YjU0OGE1ZmQ5MTQyZWVjZDFmYjhmNTRkY2U5ZWUiLCJ0eXAiOiJKV1QifQ\".as_bytes();\n//     global payload_base64url: [u8; 774] = \"eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiI2OTgxMDk0NzQ4MDUtbnZmZzloaDMxa2ptYjZtbW41MWQ0b2lvbWJncjNzM3YuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiI2OTgxMDk0NzQ4MDUtbnZmZzloaDMxa2ptYjZtbW41MWQ0b2lvbWJncjNzM3YuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMTYzMjIyNTIzMjA3NTUyMTgyMjIiLCJlbWFpbCI6ImJhc2UuZW1haWwud2FsbGV0QGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJhdF9oYXNoIjoiVzZWN2NmdURjVVhNeTNqWHNpbmRTZyIsIm5vbmNlIjoiZDhkQTZCRjI2OTY0YUY5RDdlRWQ5ZTAzRTUzNDE1RDM3YUE5NjA0NSIsIm5hbWUiOiJUZXN0IEdtYWlsIiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hL0FDZzhvY0pVa3FXYVpVMUtxX1RKMU5tak9XWUtBZ1VSc2txUl9IX21FbXVIQmVGRklCSHhWUT1zOTYtYyIsImdpdmVuX25hbWUiOiJUZXN0IiwiZmFtaWx5X25hbWUiOiJHbWFpbCIsImlhdCI6MTcyOTIwNDM2NiwiZXhwIjoxNzI5MjA3OTY2fQ\".as_bytes();\n//     global payload_json_padded: [u8; 580] = \"{\\\"iss\\\":\\\"https://accounts.google.com\\\",\\\"azp\\\":\\\"698109474805-nvfg9hh31kjmb6mmn51d4oiombgr3s3v.apps.googleusercontent.com\\\",\\\"aud\\\":\\\"698109474805-nvfg9hh31kjmb6mmn51d4oiombgr3s3v.apps.googleusercontent.com\\\",\\\"sub\\\":\\\"116322252320755218222\\\",\\\"email\\\":\\\"base.email.wallet@gmail.com\\\",\\\"email_verified\\\":true,\\\"at_hash\\\":\\\"W6V7cfuDcUXMy3jXsindSg\\\",\\\"nonce\\\":\\\"d8dA6BF26964aF9D7eEd9e03E53415D37aA96045\\\",\\\"name\\\":\\\"Test Gmail\\\",\\\"picture\\\":\\\"https://lh3.googleusercontent.com/a/ACg8ocJUkqWaZU1Kq_TJ1NmjOWYKAgURskqR_H_mEmuHBeFFIBHxVQ=s96-c\\\",\\\"given_name\\\":\\\"Test\\\",\\\"family_name\\\":\\\"Gmail\\\",\\\"iat\\\":1729204366,\\\"exp\\\":1729207966}\".as_bytes();\n\n// }\n","path":"/Users/nm/Desktop/Coding/Freelance/zui/zk-jwt/zuitzpass/src/main.nr"},"62":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/nm/nargo/github.com/zkemail/noir-jwt/v0.4.4/src/lib.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/boundary_check.nr"},"66":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/decoder.nr"},"104":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(field: Field) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<_, N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        // result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i]\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1]\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/constrained_ops.nr"},"105":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/expressions.nr"},"107":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [u128; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: u128 = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as u128;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: u128 = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as u128;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [u128; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = (val[i] as Field).to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = (val[N - 1] as Field).to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/serialization.nr"},"108":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120, TWO_POW_60};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb64;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> ([u128; N], [bool; N]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > params.modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + params.modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        borrow_flags[i] = borrow as bool;\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, params.modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = params.modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { params.modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N - 1);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[((N) - 1 - i)];\n        let v_low = v as u64 % TWO_POW_60 as u64;\n        let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n        if (v_high > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n            break;\n        }\n        if (v_low > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_helpers.nr"},"109":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> [u128; N] {\n    let f: [u128; N] = limbs;\n    __helper_sub(params.modulus, f)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, params.modulus) {\n        __helper_sub(result, params.modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    // ([0; N], [0; N])\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_ops.nr"},"111":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/params.nr"},"112":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::Neg;\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    pub unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/runtime_bignum.nr"},"119":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/utils/split_bits.nr"},"130":{"source":"use dep::bignum::RuntimeBigNum;\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\nmod tests {\n\n    use crate::types::RBN2048;\n    use super::verify_sha256_pkcs1v15;\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir_rsa/v0.7.0/src/rsa.nr"},"135":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"136":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine, lt_f};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/lib.nr"},"137":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/nm/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/utils.nr"},"139":{"source":"pub use crate::types::{Calculator, MembershipProver, Modifier, MT_Creator};\n\npub struct MerkleTree<T> {\n    pub root: T,\n    pub hasher: fn([T; 2]) -> T,\n}\n\nimpl<T> MT_Creator<T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn default(root: T, hasher: fn([T; 2]) -> T) -> Self {\n        Self { root, hasher }\n    }\n\n    fn from(root: T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::default(root, hasher)\n    }\n\n    fn new(hasher: fn([T; 2]) -> T) -> Self {\n        Self::from(T::default(), hasher)\n    }\n}\n\nimpl<T> MembershipProver<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn membership<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let root = self.calculate_root(leaf, indexes, hash_path);\n        assert(self.root == root);\n    }\n}\n\nimpl<T> Modifier<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn add<let N: u32>(&mut self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let (old, new) = self.calculate_two_roots(leaf, indexes, hash_path);\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn delete<let N: u32>(&mut self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let (new, old) = self.calculate_two_roots(leaf, indexes, hash_path);\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn update<let N: u32>(&mut self, leaf: T, old_leaf: T, indexes: Field, hash_path: [T; N]) {\n        let index_bits: [u1; N] = indexes.to_le_bits();\n\n        let mut old_parent = old_leaf;\n        let mut new_parent = leaf;\n\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if index_bits[i] == 0 {\n                new_parent = (self.hasher)([new_parent, sibling]);\n                old_parent = (self.hasher)([old_parent, sibling]);\n            } else {\n                new_parent = (self.hasher)([sibling, new_parent]);\n                old_parent = (self.hasher)([sibling, old_parent]);\n            }\n        }\n        assert(old_parent == self.root);\n        self.root = new_parent;\n    }\n}\n\nimpl<T> Calculator<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn calculate_root<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) -> T {\n        let index_bits: [u1; N] = indexes.to_le_bits();\n        let mut node = leaf;\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if index_bits[i] == 0 {\n                let left = node;\n                let right = sibling;\n                node = (self.hasher)([left, right]);\n            } else {\n                let left = sibling;\n                let right = node;\n                node = (self.hasher)([left, right]);\n            }\n        }\n        node\n    }\n\n    /*\n     * Calculates two roots for a given leaf entry based on the passed array of siblings: one root\n     * for if the leaf entry was included in the tree and one for if the leaf entry was not included\n     * in the tree. This is useful for efficiently proving the membership of leaf entries for a\n     * tree while simultaneously modifying the tree.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @returns Two root nodes: the first one doesn't include entry, the second does\n     */\n    fn calculate_two_roots<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) -> (T, T) {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n\n        // root_with_leaf is a container for hashes to derive the root node for the tree that\n        // includes the entry\n        let mut root_with_leaf = leaf;\n        // root_without_leaf is a container for hashes to derive the root node for the tree that\n        // doesn't include the entry\n        let mut root_without_leaf = T::default();\n\n        // iterate over the levels of the tree from bottom to top\n        for i in 0..hash_path.len() {\n            if i == 0 {\n                root_without_leaf = hash_path[i];\n            }\n            let sibling = hash_path[i];\n            // After the first sibling is found, the processes are started to calculate the two root nodes.\n            // The calulcation of the root node that includes the entry is comparable to `calculate_root`.\n            // To calc the root node that doesn't include entry, the first sibling is put into the container\n            // and starting from each SUBSEQUENT iteration it is hashed with its sibling and the resulting hash\n            // again stored in the container until the root is reached\n            if index_bits[i] == 0 {\n                root_with_leaf = (self.hasher)([root_with_leaf, sibling]);\n                if (root_without_leaf != sibling) {\n                    root_without_leaf = (self.hasher)([root_without_leaf, sibling]);\n                }\n            } else {\n                root_with_leaf = (self.hasher)([sibling, root_with_leaf]);\n                if (root_without_leaf != sibling) {\n                    root_without_leaf = (self.hasher)([sibling, root_without_leaf]);\n                }\n            }\n        }\n        (root_without_leaf, root_with_leaf)\n    }\n}\n","path":"/Users/nm/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/merkle-trees-v0.0.1/packages/merkle-trees/src/merkle.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","get_lt_predicate_f","directive_integer_quotient","directive_invert","directive_to_radix"]}